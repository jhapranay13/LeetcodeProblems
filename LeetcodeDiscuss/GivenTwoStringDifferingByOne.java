package LeetcodeDiscuss;

import java.util.ArrayList;
import java.util.List;

/**
 *
 * Given two strings, str1, and str2, where str1 contains exactly one character more than str2, find the indices of the characters in str1 that can be removed to make str1 equal to str2. Return the array of indices in increasing order. If it is not possible, return the array [-1].
 *
 * str1 = "abdgggda"
 *
 * str2 = "abdggda"
 *
 * Any "g" character at positions 3, 4, or 5 can be deleted to obtain str2. Return [3, 4, 5].
 *
 */

public class GivenTwoStringDifferingByOne {

    public static void main(String... args) {

        String str1 = "abdgggda";
        String str2 = "abdggda";

        //String str1 = "aabdca";
        //String str2 = "abdca";
        List<Integer> result = findIndices(str1, str2);
        for (int index : result) {
            System.out.print(index + " ");
        }
        // Wrong answer generated by ChatGpt
        System.out.println(findRemovalIndices(str1, str2));
    }

    private static List<Integer> findIndices(String str1, String str2) {
        List<Integer> indices = new ArrayList<>();

        if (str1.length() != str2.length() + 1) {
            indices.add(-1);
            return indices;
        }
        long prime = 31;
        long hashStr2 = getHash(str2, 0, str2.length() - 1, prime);
        // ignoring the first character
        long hashStr1 = getHash(str1, 1, str1.length() - 1, prime);
        long pow = 1;

        for (int i = 0; i < str1.length(); i++) {

            if (hashStr1 == hashStr2) {
                indices.add(i);
            }
            // Removing the character
            if (i + 1 < str1.length()) {
                long temp = hashStr1 - ((str1.charAt(i + 1) - 'a' + 1) * pow) % mod;

                if (temp < 0) {
                    temp += mod;
                    temp %= mod;
                }
                hashStr1 = temp;
            }
            //adding i value;
            hashStr1 = (hashStr1 + ((str1.charAt(i) - 'a' + 1) * pow) % mod) % mod;
            pow = (pow * prime) % mod;
        }
        if (indices.isEmpty()) {
            indices.add(-1);
        }

        return indices;
    }

    private static long mod = 1000000007;

    private static long getHash(String str2, int lo, int hi, long prime) {
        long hash = 0;
        long pow = 1;

        for (int i = lo; i <= hi; i++) {
            hash = (hash + ((str2.charAt(i) - 'a' + 1) * pow) % mod) % mod;
            pow = (pow * prime) % mod;
        }
        return hash;
    }
    //=============================================================================================
    // Testing

    public static List<Integer> findRemovalIndices(String str1, String str2) {
        List<Integer> result = new ArrayList<>();

        // Length of str1 must be one more than str2
        if (str1.length() != str2.length() + 1) {
            result.add(-1);
            return result;
        }

        // Compare both strings character by character
        int i = 0, j = 0;

        // Check each position of str1 for a potential removal
        while (i < str1.length()) {
            if (j < str2.length() && str1.charAt(i) == str2.charAt(j)) {
                // If characters match, continue
                i++;
                j++;
            } else {
                // If they don't match, the mismatch must be in str1 at index i
                result.add(i);
                i++;  // Skip the character at index i in str1
            }
        }

        // If we have found indices where removal works, return them
        if (result.isEmpty()) {
            result.add(-1);
        }

        return result;
    }
}
